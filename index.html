<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DQM1ãƒ»2 PSç‰ˆ é…åˆãƒŠãƒ“ã€å®Œå…¨ç‰ˆã€‘</title>
    <style>
        :root {
            --bg: #0f172a; --card: #1e293b; --text: #f8fafc; --accent: #38bdf8; --border: #475569;
            --target-bg: #38bdf8; --start-bg: #fb7185; --family-text: #f472b6;
        }
        body { font-family: 'Segoe UI', Meiryo, sans-serif; background: var(--bg); color: var(--text); padding: 15px; margin: 0; }
        .wrapper { max-width: 900px; margin: 0 auto; }
        header { text-align: center; border-bottom: 2px solid var(--accent); padding-bottom: 10px; margin-bottom: 20px; }
        .card { background: var(--card); padding: 15px; border-radius: 12px; border: 1px solid var(--border); margin-bottom: 20px; }
        label { display: block; margin-bottom: 5px; font-weight: bold; color: var(--accent); }
        select, button { width: 100%; padding: 12px; border-radius: 6px; margin-bottom: 10px; font-weight: bold; font-size: 16px; box-sizing: border-box; }
        button { background: var(--accent); color: #0f172a; border: none; cursor: pointer; }

        /* --- ç¸¦æ–¹å‘ã®å®¶ç³»å›³ --- */
        .tree-container { background: #000; border-radius: 8px; border: 1px solid var(--accent); padding: 20px 5px; overflow-x: auto; }
        .tree { display: flex; justify-content: center; }
        .tree ul { padding-top: 25px; position: relative; display: flex; justify-content: center; list-style: none; margin: 0; padding-left: 0; }
        .tree li { float: left; text-align: center; list-style-type: none; position: relative; padding: 25px 5px 0 5px; }

        /* ã¤ãªãç·š */
        .tree li::before, .tree li::after { content: ''; position: absolute; top: 0; right: 50%; border-top: 2px solid var(--border); width: 50%; height: 25px; }
        .tree li::after { right: auto; left: 50%; border-left: 2px solid var(--border); }
        .tree li:only-child::after, .tree li:only-child::before { display: none; }
        .tree li:only-child { padding-top: 0; }
        .tree li:first-child::before, .tree li:last-child::after { border: 0 none; }
        .tree li:last-child::before { border-right: 2px solid var(--border); border-radius: 0 5px 0 0; }
        .tree li:first-child::after { border-radius: 5px 0 0 0; }
        .tree ul ul::before { content: ''; position: absolute; top: 0; left: 50%; border-left: 2px solid var(--border); width: 0; height: 25px; }

        /* ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®ç®± */
        .monster-wrapper { position: relative; display: inline-block; }
        .node {
            display: block; padding: 8px 12px; border-radius: 6px;
            background: var(--card); border: 2px solid var(--border);
            font-weight: bold; cursor: pointer; white-space: nowrap; transition: 0.2s;
            font-size: 13px; z-index: 10; position: relative;
        }
        /* é–‹é–‰ãƒãƒ¼ã‚¯ */
        .node.can-expand::before { content: '[+] '; color: var(--accent); font-family: monospace; }
        .node.expanded::before { content: '[-] '; color: var(--start-bg); }

        .node:hover { border-color: var(--accent); background: #334155; }
        .node.target { background: var(--target-bg); color: #000; }
        .node.start { background: var(--start-bg); color: #000; border-color: #fff; }
        .node.family { color: var(--family-text); cursor: default; border-style: dotted; pointer-events: none; }
        .node.family::before { content: '' !important; }

        /* ãƒ—ãƒ©ã‚¹å€¤è¡¨ç¤º */
        .plus-req { font-size: 10px; color: #fbbf24; display: block; margin-top: 2px; font-weight: bold; background: rgba(251, 191, 36, 0.1); border-radius: 4px; }

        .switcher { display: flex; justify-content: center; gap: 2px; margin-top: 4px; }
        .r-btn { font-size: 9px; padding: 2px 4px; background: #1e293b; color: #fff; border: 1px solid var(--border); cursor: pointer; border-radius: 3px; }
        .r-btn.active { background: var(--accent); color: #000; }
        
        .hint { font-size: 0.8em; color: #94a3b8; text-align: center; margin-bottom: 10px; }
    </style>
</head>
<body>
<div class="wrapper">
    <header><h1>ğŸ‘¾ DQM1ãƒ»2 PSç‰ˆ å®Œå…¨é…åˆãƒŠãƒ“</h1></header>
    <div class="card">
        <label>1. ç›®æ¨™ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼</label>
        <select id="familySelect" onchange="updateTargetList()"></select>
        <select id="targetSelect" disabled onchange="resetAndGenerate()"></select>
        <label>2. æ‰‹æŒã¡ã‹ã‚‰é–‹å§‹ (ä»»æ„)</label>
        <select id="startSelect" disabled onchange="generateTree()"></select>
        <button onclick="fullReset()">å…¨ã¦ã®é–‹é–‰ã‚’é–‰ã˜ã‚‹</button>
    </div>
    <div id="resultCard" class="card" style="display:none;">
        <div class="tree-container"><div id="output" class="tree"></div></div>
    </div>
</div>

<script>
let monsterFamilies = {};
let fusionRecipes = {};
let familyMixMap = {};
let selectedRecipeIndices = {}; 
let expandedNodes = new Set(); 

async function loadData() {
    try {
        const [resFam, resFus, resMix] = await Promise.all([
            fetch('family_list.json'), fetch('fusion_list.json'), fetch('family_mixing.json')
        ]);
        monsterFamilies = await resFam.json();
        fusionRecipes = await resFus.json();
        familyMixMap = await resMix.json();

        // ç³»çµ±é…åˆã‚’ãƒ¬ã‚·ãƒ”ã«æ³¨å…¥
        for (let f1 in familyMixMap) {
            for (let f2 in familyMixMap[f1]) {
                let resName = familyMixMap[f1][f2];
                if (!fusionRecipes.recipes[resName]) {
                    fusionRecipes.recipes[resName] = [[f1, f2]];
                }
            }
        }

        // å…¨ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã®é…åˆãƒ«ãƒ¼ãƒˆè‡ªå‹•è£œå®Œï¼ˆãƒ‰ãƒ©ã‚´ãƒ³ç­‰ï¼‰
        const allMonsters = [].concat(...Object.values(monsterFamilies));
        allMonsters.forEach(m => {
            if (!fusionRecipes.recipes[m]) {
                for (let fName in monsterFamilies) {
                    if (monsterFamilies[fName].includes(m)) {
                        fusionRecipes.recipes[m] = [[fName, fName]];
                        break;
                    }
                }
            }
        });

        const fSel = document.getElementById('familySelect');
        fSel.innerHTML = '<option value="">-- ç³»çµ±ã‚’é¸æŠ --</option>';
        Object.keys(monsterFamilies).sort().forEach(f => fSel.add(new Option(f, f)));
    } catch (e) { alert("JSONèª­ã¿è¾¼ã¿å¤±æ•—"); console.error(e); }
}

function updateTargetList() {
    const tSel = document.getElementById('targetSelect');
    const f = document.getElementById('familySelect').value;
    tSel.innerHTML = '<option value="">-- ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’é¸æŠ --</option>';
    if (f) { monsterFamilies[f].sort().forEach(m => tSel.add(new Option(m, m))); tSel.disabled = false; }
    updateStartList();
}

function resetAndGenerate() {
    selectedRecipeIndices = {}; expandedNodes = new Set();
    const target = document.getElementById('targetSelect').value;
    if(target) expandedNodes.add(target);
    updateStartList();
    generateTree();
}

function fullReset() {
    expandedNodes = new Set();
    const target = document.getElementById('targetSelect').value;
    if(target) expandedNodes.add(target);
    generateTree();
}

function updateStartList() {
    const sSel = document.getElementById('startSelect');
    const target = document.getElementById('targetSelect').value;
    sSel.innerHTML = '<option value="">-- æœ€åˆã‹ã‚‰è¨ˆç®— --</option>';
    if (!target) { sSel.disabled = true; return; }
    
    const related = new Set();
    const q = [target];
    const visited = new Set();
    while(q.length > 0) {
        const cur = q.shift();
        if (visited.has(cur)) continue; visited.add(cur);
        const routes = fusionRecipes.recipes[cur];
        if (!routes) continue;
        routes.forEach(route => {
            // æ¡ä»¶(+5ç­‰)ã‚’é™¤å¤–ã—ã¦ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼åã ã‘ãƒªã‚¹ãƒˆåŒ–
            [route[0], route[1]].forEach(p => {
                if (p && !monsterFamilies[p]) { related.add(p); q.push(p); }
            });
        });
    }
    Array.from(related).sort().forEach(m => sSel.add(new Option(m, m)));
    sSel.disabled = false;
}

function toggleNode(name) {
    if (monsterFamilies[name]) return; 
    if (expandedNodes.has(name)) expandedNodes.delete(name);
    else expandedNodes.add(name);
    generateTree();
}

function buildTreeHTML(name, isTarget = false) {
    const start = document.getElementById('startSelect').value;
    const isFamily = !!monsterFamilies[name];
    const isExpanded = expandedNodes.has(name);
    const routes = fusionRecipes.recipes[name];
    
    let nodeClass = 'node';
    if (isTarget) nodeClass += ' target';
    if (isFamily) nodeClass += ' family';
    if (name === start && start !== "") nodeClass += ' start';
    if (routes && !isFamily) nodeClass += ' can-expand';
    if (isExpanded) nodeClass += ' expanded';

    const canToggle = !isFamily && (name !== start || start === "");
    const clickAttr = canToggle ? `onclick="toggleNode('${name}')"` : '';

    let html = `<li><div class="monster-wrapper">`;
    html += `<span class="${nodeClass}" ${clickAttr}>${name}</span>`;

    if (name === start && start !== "") {
        html += `</div></li>`; return html;
    }

    if (!isFamily && routes) {
        const idx = selectedRecipeIndices[name] || 0;
        const currentRecipe = routes[idx];
        
        if (currentRecipe && currentRecipe[2]) {
            html += `<span class="plus-req">${currentRecipe[2]}</span>`;
        }

        if (routes.length > 1) {
            html += `<div class="switcher">`;
            routes.forEach((_, i) => {
                html += `<button class="r-btn ${i === idx ? 'active' : ''}" onclick="event.stopPropagation(); selectedRecipeIndices['${name}']=${i}; generateTree();">R${i+1}</button>`;
            });
            html += `</div>`;
        }
        if (isExpanded && canToggle && currentRecipe) {
            html += `</div><ul>`;
            html += buildTreeHTML(currentRecipe[0]);
            html += buildTreeHTML(currentRecipe[1]);
            html += `</ul>`;
        } else { html += `</div>`; }
    } else { html += `</div>`; }
    html += `</li>`;
    return html;
}

function generateTree() {
    const target = document.getElementById('targetSelect').value;
    if (!target) return;
    document.getElementById('resultCard').style.display = 'block';
    document.getElementById('output').innerHTML = `<ul>${buildTreeHTML(target, true)}</ul>`;
}

loadData();
</script>
</body>
</html>
