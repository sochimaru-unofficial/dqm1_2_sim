let monsterFamilies = {};
let fusionRecipes = {};
let familyMixMap = {};
let selectedRecipeIndices = {}; 
let expandedNodes = new Set(); 

async function loadData() {
    try {
        const [resFam, resFus, resMix] = await Promise.all([
            fetch('family_list.json'), fetch('fusion_list.json'), fetch('family_mixing.json')
        ]);
        monsterFamilies = await resFam.json();
        fusionRecipes = await resFus.json();
        familyMixMap = await resMix.json();

        // 系統配合の逆引きをレシピに注入（特殊レシピがない場合のみ）
        for (let f1 in familyMixMap) {
            for (let f2 in familyMixMap[f1]) {
                let resName = familyMixMap[f1][f2];
                if (!fusionRecipes.recipes[resName]) {
                    fusionRecipes.recipes[resName] = [[f1, f2]];
                }
            }
        }
        
        // --- ここが修正ポイント１：系統内配合などの基本ルートを補完 ---
        // 「ドラゴン」や「サンダーバード」のように個別のレシピがない場合、その系統の基本配合を提示する
        const allMonsters = [].concat(...Object.values(monsterFamilies));
        allMonsters.forEach(m => {
            if (!fusionRecipes.recipes[m]) {
                // 系統を見つける
                for (let familyName in monsterFamilies) {
                    if (monsterFamilies[familyName].includes(m)) {
                        // 系統×系統（同系統など）をデフォルトレシピとして仮置き
                        fusionRecipes.recipes[m] = [[familyName, familyName]];
                        break;
                    }
                }
            }
        });

        const fSel = document.getElementById('familySelect');
        fSel.innerHTML = '<option value="">-- 系統を選択 --</option>';
        Object.keys(monsterFamilies).sort().forEach(f => fSel.add(new Option(f, f)));
    } catch (e) { alert("JSON読み込み失敗"); console.error(e); }
}

function updateTargetList() {
    const tSel = document.getElementById('targetSelect');
    const f = document.getElementById('familySelect').value;
    tSel.innerHTML = '<option value="">-- モンスターを選択 --</option>';
    if (f) { monsterFamilies[f].sort().forEach(m => tSel.add(new Option(m, m))); tSel.disabled = false; }
    updateStartList();
}

function resetAndGenerate() {
    selectedRecipeIndices = {}; expandedNodes = new Set();
    const target = document.getElementById('targetSelect').value;
    if(target) expandedNodes.add(target);
    updateStartList();
    generateTree();
}

function fullReset() {
    expandedNodes = new Set();
    const target = document.getElementById('targetSelect').value;
    if(target) expandedNodes.add(target);
    generateTree();
}

function updateStartList() {
    const sSel = document.getElementById('startSelect');
    const target = document.getElementById('targetSelect').value;
    sSel.innerHTML = '<option value="">-- 最初から計算 --</option>';
    if (!target) { sSel.disabled = true; return; }
    
    const related = new Set();
    const q = [target];
    const visited = new Set();
    
    while(q.length > 0) {
        const cur = q.shift();
        if (visited.has(cur)) continue; visited.add(cur);
        const routes = fusionRecipes.recipes[cur];
        if (!routes) continue;
        
        routes.forEach(route => {
            // --- ここが修正ポイント２：+5などの条件をリストから除外 ---
            // 0番目と1番目（親の名前）だけをチェックし、2番目（条件）は無視する
            [route[0], route[1]].forEach(p => {
                if (p && !monsterFamilies[p]) { 
                    related.add(p); 
                    q.push(p); 
                }
            });
        });
    }
    Array.from(related).sort().forEach(m => sSel.add(new Option(m, m)));
    sSel.disabled = false;
}

function toggleNode(name) {
    if (monsterFamilies[name]) return; 
    if (expandedNodes.has(name)) expandedNodes.delete(name);
    else expandedNodes.add(name);
    generateTree();
}

function buildTreeHTML(name, isTarget = false) {
    const start = document.getElementById('startSelect').value;
    const isFamily = !!monsterFamilies[name];
    const isExpanded = expandedNodes.has(name);
    const routes = fusionRecipes.recipes[name];
    
    let nodeClass = 'node';
    if (isTarget) nodeClass += ' target';
    if (isFamily) nodeClass += ' family';
    if (name === start && start !== "") nodeClass += ' start';
    if (routes && !isFamily) nodeClass += ' can-expand';
    if (isExpanded) nodeClass += ' expanded';

    const canToggle = !isFamily && (name !== start || start === "");
    const clickAttr = canToggle ? `onclick="toggleNode('${name}')"` : '';

    let html = `<li><div class="monster-wrapper">`;
    html += `<span class="${nodeClass}" ${clickAttr}>${name}</span>`;

    if (name === start && start !== "") {
        html += `</div></li>`; return html;
    }

    if (!isFamily && routes) {
        const idx = selectedRecipeIndices[name] || 0;
        const currentRecipe = routes[idx];
        
        if (currentRecipe && currentRecipe[2]) {
            html += `<span class="plus-req">${currentRecipe[2]}</span>`;
        }

        if (routes.length > 1) {
            html += `<div class="switcher">`;
            routes.forEach((_, i) => {
                html += `<button class="r-btn ${i === idx ? 'active' : ''}" onclick="event.stopPropagation(); selectedRecipeIndices['${name}']=${i}; generateTree();">R${i+1}</button>`;
            });
            html += `</div>`;
        }
        if (isExpanded && canToggle && currentRecipe) {
            html += `</div><ul>`;
            html += buildTreeHTML(currentRecipe[0]);
            html += buildTreeHTML(currentRecipe[1]);
            html += `</ul>`;
        } else { html += `</div>`; }
    } else { html += `</div>`; }
    html += `</li>`;
    return html;
}

function generateTree() {
    const target = document.getElementById('targetSelect').value;
    if (!target) return;
    document.getElementById('resultCard').style.display = 'block';
    document.getElementById('output').innerHTML = `<ul>${buildTreeHTML(target, true)}</ul>`;
}

loadData();
